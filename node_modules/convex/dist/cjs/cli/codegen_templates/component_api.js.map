{
  "version": 3,
  "sources": ["../../../../src/cli/codegen_templates/component_api.ts"],
  "sourcesContent": ["import path from \"path\";\nimport { Context } from \"../../bundler/context.js\";\nimport { entryPoints } from \"../../bundler/index.js\";\nimport {\n  ComponentDirectory,\n  toAbsolutePath,\n  toComponentDefinitionPath,\n  ComponentDefinitionPath,\n} from \"../lib/components/definition/directoryStructure.js\";\nimport { StartPushResponse } from \"../lib/deployApi/startPush.js\";\nimport { importPath, moduleIdentifier } from \"./api.js\";\nimport { apiComment, compareStrings, header } from \"./common.js\";\nimport {\n  ComponentExports,\n  EvaluatedComponentDefinition,\n} from \"../lib/deployApi/componentDefinition.js\";\nimport { Identifier, Reference } from \"../lib/deployApi/types.js\";\nimport { CanonicalizedModulePath } from \"../lib/deployApi/paths.js\";\nimport {\n  AnalyzedFunction,\n  AnalyzedModule,\n  Visibility,\n} from \"../lib/deployApi/modules.js\";\nimport { parseValidator, validatorToType } from \"./validator_helpers.js\";\n\nexport function componentApiJs() {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`\n    import { anyApi, componentsGeneric } from \"convex/server\";\n\n    ${apiComment(\"api\", undefined)}\n    export const api = anyApi;\n    export const internal = anyApi;\n    export const components = componentsGeneric();\n  `);\n  return lines.join(\"\\n\");\n}\n\nexport function rootComponentApiCJS() {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`const { anyApi } = require(\"convex/server\");`);\n  lines.push(`module.exports = {\n    api: anyApi,\n    internal: anyApi,\n  };`);\n  return lines.join(\"\\n\");\n}\n\nexport function componentApiStubDTS() {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`import type { AnyApi, AnyComponents } from \"convex/server\";`);\n  lines.push(`\n    export declare const api: AnyApi;\n    export declare const internal: AnyApi;\n    export declare const components: AnyComponents;\n  `);\n\n  return lines.join(\"\\n\");\n}\n\n// This is also used for root components\nexport function componentApiStubTS() {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`\n    import type { AnyApi, AnyComponents } from \"convex/server\";\n    import { anyApi, componentsGeneric } from \"convex/server\";\n\n    export const api: AnyApi = anyApi;\n    export const internal: AnyApi = anyApi;\n    export const components: AnyComponents = componentsGeneric();\n  `);\n  return lines.join(\"\\n\");\n}\n\nexport async function componentApiDTS(\n  ctx: Context,\n  startPush: StartPushResponse,\n  rootComponent: ComponentDirectory,\n  componentDirectory: ComponentDirectory,\n  componentsMap: Map<string, ComponentDirectory>,\n  opts: { staticApi: boolean; useComponentApiImports: boolean },\n) {\n  const definitionPath = toComponentDefinitionPath(\n    rootComponent,\n    componentDirectory,\n  );\n\n  const analysis = startPush.analysis[definitionPath];\n  if (!analysis) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `No analysis found for component ${definitionPath} orig: ${definitionPath}\\nin\\n${Object.keys(startPush.analysis).toString()}`,\n    });\n  }\n\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  let apiLines: AsyncGenerator<string>;\n  if (opts.staticApi) {\n    apiLines = codegenStaticApiObjects(ctx, analysis);\n  } else {\n    apiLines = codegenDynamicApiObjects(ctx, componentDirectory);\n  }\n  for await (const line of apiLines) {\n    lines.push(line);\n  }\n\n  lines.push(`\n  export declare const components: {`);\n  for (const childComponent of analysis.definition.childComponents) {\n    const childComponentAnalysis = startPush.analysis[childComponent.path];\n    if (!childComponentAnalysis) {\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `No analysis found for child component ${childComponent.path}`,\n      });\n    }\n    if (opts.useComponentApiImports) {\n      const absolutePath = toAbsolutePath(\n        rootComponent,\n        childComponent.path as ComponentDefinitionPath,\n      );\n\n      let childComponentWithRelativePath = componentsMap?.get(absolutePath);\n      if (!childComponentWithRelativePath) {\n        return await ctx.crash({\n          exitCode: 1,\n          errorType: \"fatal\",\n          printedMessage: `Invalid child component directory: ${childComponent.path}`,\n        });\n      }\n\n      let importPath;\n\n      // If the user uses a different import specifier than the absolute path of the child component, use the import specifier.\n      if (\n        childComponentWithRelativePath.importSpecifier &&\n        childComponentWithRelativePath.importSpecifier !== childComponent.path\n      ) {\n        importPath = childComponentWithRelativePath.importSpecifier;\n      } else {\n        importPath = `../${childComponent.path}`;\n      }\n      lines.push(\n        `  \"${childComponent.name}\": import(\"${importPath}/_generated/component.js\").ComponentApi<\"${childComponent.name}\">,`,\n      );\n    } else {\n      for await (const line of codegenExports(\n        ctx,\n        childComponent.name,\n        childComponentAnalysis,\n      )) {\n        lines.push(line);\n      }\n    }\n  }\n\n  lines.push(\"};\");\n\n  return lines.join(\"\\n\");\n}\n\nexport async function componentTS(\n  ctx: Context,\n  startPush: StartPushResponse,\n  rootComponent: ComponentDirectory,\n  componentDirectory: ComponentDirectory,\n) {\n  const definitionPath = toComponentDefinitionPath(\n    rootComponent,\n    componentDirectory,\n  );\n  const analysis = startPush.analysis[definitionPath];\n  if (!analysis) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `No analysis found for component ${definitionPath} orig: ${definitionPath}\\nin\\n${Object.keys(startPush.analysis).toString()}`,\n    });\n  }\n\n  const lines = [];\n  lines.push(header(\"Generated `ComponentApi` utility.\"));\n  lines.push(`\n    import type { FunctionReference } from \"convex/server\";\n\n    /**\n    * A utility for referencing a Convex component's exposed API.\n    *\n    * Useful when expecting a parameter like \\`components.myComponent\\`.\n    * Usage:\n    * \\`\\`\\`ts\n    * async function myFunction(ctx: QueryCtx, component: ComponentApi) {\n    *   return ctx.runQuery(component.someFile.someQuery, { ...args });\n    * }\n    * \\`\\`\\`\n    */`);\n  lines.push(\n    `export type ComponentApi<Name extends string | undefined = string | undefined> = `,\n  );\n  for await (const line of codegenExport(\n    ctx,\n    analysis,\n    analysis.definition.exports,\n    \"Name\",\n  )) {\n    lines.push(line);\n  }\n  lines.push(`;`);\n  return lines.join(\"\\n\");\n}\n\nexport async function componentApiTSWithTypes(\n  ctx: Context,\n  startPush: StartPushResponse,\n  rootComponent: ComponentDirectory,\n  componentDirectory: ComponentDirectory,\n  componentsMap: Map<string, ComponentDirectory>,\n  opts: { staticApi: boolean; useComponentApiImports: boolean },\n) {\n  const definitionPath = toComponentDefinitionPath(\n    rootComponent,\n    componentDirectory,\n  );\n\n  const analysis = startPush.analysis[definitionPath];\n  if (!analysis) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `No analysis found for component ${definitionPath} orig: ${definitionPath}\\nin\\n${Object.keys(startPush.analysis).toString()}`,\n    });\n  }\n\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  let apiLines: AsyncGenerator<string>;\n  if (opts.staticApi) {\n    apiLines = codegenStaticApiObjectsTS(ctx, analysis);\n  } else {\n    apiLines = codegenDynamicApiObjectsTS(ctx, componentDirectory);\n  }\n  for await (const line of apiLines) {\n    lines.push(line);\n  }\n\n  // Generate components section\n  lines.push(`\n  export const components = componentsGeneric() as unknown as {`);\n  for (const childComponent of analysis.definition.childComponents) {\n    const childComponentAnalysis = startPush.analysis[childComponent.path];\n    if (!childComponentAnalysis) {\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `No analysis found for child component ${childComponent.path}`,\n      });\n    }\n    if (opts.useComponentApiImports) {\n      const absolutePath = toAbsolutePath(\n        rootComponent,\n        childComponent.path as ComponentDefinitionPath,\n      );\n\n      let childComponentWithRelativePath = componentsMap?.get(absolutePath);\n      if (!childComponentWithRelativePath) {\n        return await ctx.crash({\n          exitCode: 1,\n          errorType: \"fatal\",\n          printedMessage: `Invalid child component directory: ${childComponent.path}`,\n        });\n      }\n\n      let importPath;\n\n      // If the user uses a different import specifier than the absolute path of the child component, use the import specifier.\n      if (\n        childComponentWithRelativePath.importSpecifier &&\n        childComponentWithRelativePath.importSpecifier !== childComponent.path\n      ) {\n        importPath = childComponentWithRelativePath.importSpecifier;\n      } else {\n        importPath = `../${childComponent.path}`;\n      }\n      lines.push(\n        `  \"${childComponent.name}\": import(\"${importPath}/_generated/component.js\").ComponentApi<\"${childComponent.name}\">,`,\n      );\n    } else {\n      for await (const line of codegenExports(\n        ctx,\n        childComponent.name,\n        childComponentAnalysis,\n      )) {\n        lines.push(line);\n      }\n    }\n  }\n  lines.push(\"};\");\n\n  return lines.join(\"\\n\");\n}\n\nasync function* codegenStaticApiObjects(\n  ctx: Context,\n  analysis: EvaluatedComponentDefinition,\n) {\n  yield `import type { FunctionReference } from \"convex/server\";`;\n  yield `import type { GenericId as Id } from \"convex/values\";`;\n\n  const apiTree = await buildApiTree(ctx, analysis.functions, {\n    kind: \"public\",\n  });\n  yield apiComment(\"api\", \"public\");\n  yield `export declare const api:`;\n  yield* codegenApiTree(ctx, apiTree);\n  yield \";\";\n\n  yield apiComment(\"internal\", \"internal\");\n  const internalTree = await buildApiTree(ctx, analysis.functions, {\n    kind: \"internal\",\n  });\n  yield `export declare const internal:`;\n  yield* codegenApiTree(ctx, internalTree);\n  yield \";\";\n}\n\nasync function* codegenStaticApiObjectsTS(\n  ctx: Context,\n  analysis: EvaluatedComponentDefinition,\n) {\n  yield `import type { FunctionReference } from \"convex/server\";`;\n  yield `import type { GenericId as Id } from \"convex/values\";`;\n  yield `import { anyApi, componentsGeneric } from \"convex/server\";`;\n\n  const apiTree = await buildApiTree(ctx, analysis.functions, {\n    kind: \"public\",\n  });\n  yield apiComment(\"api\", \"public\");\n  yield `export const api:`;\n  yield* codegenApiTree(ctx, apiTree);\n  yield \"= anyApi as any;\";\n\n  yield apiComment(\"internal\", \"internal\");\n  const internalTree = await buildApiTree(ctx, analysis.functions, {\n    kind: \"internal\",\n  });\n  yield `export const internal:`;\n  yield* codegenApiTree(ctx, internalTree);\n  yield \"= anyApi as any;\";\n}\n\nasync function* codegenDynamicApiObjects(\n  ctx: Context,\n  componentDirectory: ComponentDirectory,\n) {\n  const absModulePaths = await entryPoints(ctx, componentDirectory.path);\n  const modulePaths = absModulePaths\n    .map((p) => path.relative(componentDirectory.path, p))\n    .sort();\n  for (const modulePath of modulePaths) {\n    const ident = moduleIdentifier(modulePath);\n    const path = importPath(modulePath);\n    yield `import type * as ${ident} from \"../${path}.js\";`;\n  }\n  yield `\n    import type {\n      ApiFromModules,\n      FilterApi,\n      FunctionReference,\n    } from \"convex/server\";\n\n    declare const fullApi: ApiFromModules<{\n  `;\n  for (const modulePath of modulePaths) {\n    const ident = moduleIdentifier(modulePath);\n    const path = importPath(modulePath);\n    yield `  \"${path}\": typeof ${ident},`;\n  }\n  yield `}>;`;\n  yield `\n    ${apiComment(\"api\", \"public\")}\n    export declare const api: FilterApi<typeof fullApi, FunctionReference<any, \"public\">>;\n    ${apiComment(\"internal\", \"internal\")}\n    export declare const internal: FilterApi<typeof fullApi, FunctionReference<any, \"internal\">>;\n  `;\n}\n\nasync function* codegenDynamicApiObjectsTS(\n  ctx: Context,\n  componentDirectory: ComponentDirectory,\n) {\n  const absModulePaths = await entryPoints(ctx, componentDirectory.path);\n  const modulePaths = absModulePaths\n    .map((p) => path.relative(componentDirectory.path, p))\n    .sort();\n  for (const modulePath of modulePaths) {\n    const ident = moduleIdentifier(modulePath);\n    const path = importPath(modulePath);\n    yield `import type * as ${ident} from \"../${path}.js\";`;\n  }\n  yield `\n    import type {\n      ApiFromModules,\n      FilterApi,\n      FunctionReference,\n    } from \"convex/server\";\n    import { anyApi, componentsGeneric } from \"convex/server\";\n\n    const fullApi: ApiFromModules<{\n  `;\n  for (const modulePath of modulePaths) {\n    const ident = moduleIdentifier(modulePath);\n    const path = importPath(modulePath);\n    yield `  \"${path}\": typeof ${ident},`;\n  }\n  yield `}> = anyApi as any;`;\n  yield `\n    ${apiComment(\"api\", \"public\")}\n    export const api: FilterApi<typeof fullApi, FunctionReference<any, \"public\">> = anyApi as any;\n    ${apiComment(\"internal\", \"internal\")}\n    export const internal: FilterApi<typeof fullApi, FunctionReference<any, \"internal\">> = anyApi as any;\n  `;\n}\n\ninterface ApiTree {\n  [identifier: string]:\n    | { type: \"branch\"; branch: ApiTree }\n    | { type: \"leaf\"; leaf: AnalyzedFunction };\n}\n\nasync function buildApiTree(\n  ctx: Context,\n  functions: Record<CanonicalizedModulePath, AnalyzedModule>,\n  visibility: Visibility,\n): Promise<ApiTree> {\n  const root: ApiTree = {};\n  for (const [modulePath, module] of Object.entries(functions)) {\n    const p = importPath(modulePath);\n    if (p.startsWith(\"_deps/\")) {\n      continue;\n    }\n    for (const f of module.functions) {\n      if (f.visibility?.kind !== visibility.kind) {\n        continue;\n      }\n      let current = root;\n      for (const pathComponent of p.split(\"/\")) {\n        let next = current[pathComponent];\n        if (!next) {\n          next = { type: \"branch\", branch: {} };\n          current[pathComponent] = next;\n        }\n        if (next.type === \"leaf\") {\n          return await ctx.crash({\n            exitCode: 1,\n            errorType: \"fatal\",\n            printedMessage: `Ambiguous function name: ${f.name} in ${modulePath}`,\n          });\n        }\n        current = next.branch;\n      }\n      if (current[f.name]) {\n        return await ctx.crash({\n          exitCode: 1,\n          errorType: \"fatal\",\n          printedMessage: `Duplicate function name: ${f.name} in ${modulePath}`,\n        });\n      }\n      current[f.name] = { type: \"leaf\", leaf: f };\n    }\n  }\n  return root;\n}\n\nasync function* codegenApiTree(\n  ctx: Context,\n  tree: ApiTree,\n): AsyncGenerator<string> {\n  yield \"{\";\n  // Sort entries alphabetically for stable output\n  const sortedEntries = Object.entries(tree).sort(([a], [b]) =>\n    compareStrings(a, b),\n  );\n  for (const [identifier, subtree] of sortedEntries) {\n    if (subtree.type === \"branch\") {\n      yield `\"${identifier}\":`;\n      yield* codegenApiTree(ctx, subtree.branch);\n      yield \",\";\n    } else {\n      const visibility = subtree.leaf.visibility?.kind;\n      if (!visibility) {\n        return await ctx.crash({\n          exitCode: 1,\n          errorType: \"fatal\",\n          printedMessage: `Function ${subtree.leaf.name} has no visibility`,\n        });\n      }\n      const ref = await codegenFunctionReference(\n        ctx,\n        subtree.leaf,\n        visibility,\n        true,\n        undefined,\n      );\n      yield `\"${identifier}\": ${ref},`;\n    }\n  }\n  yield \"}\";\n}\n\nasync function* codegenExports(\n  ctx: Context,\n  name: Identifier,\n  analysis: EvaluatedComponentDefinition,\n): AsyncGenerator<string> {\n  yield `${name}: {`;\n  const exports = analysis.definition.exports.branch;\n  const entries = Array.from(exports).sort(([a], [b]) => compareStrings(a, b));\n  for (const [name, componentExport] of entries) {\n    yield `${name}:`;\n    yield* codegenExport(ctx, analysis, componentExport, undefined);\n    yield \",\";\n  }\n  yield \"},\";\n}\n\nasync function* codegenExport(\n  ctx: Context,\n  analysis: EvaluatedComponentDefinition,\n  componentExport: ComponentExports,\n  componentPath: string | undefined,\n): AsyncGenerator<string> {\n  if (componentExport.type === \"leaf\") {\n    yield await resolveFunctionReference(\n      ctx,\n      analysis,\n      componentExport.leaf,\n      \"internal\",\n      componentPath,\n    );\n  } else if (componentExport.type === \"branch\") {\n    yield \"{\";\n    const entries = Array.from(componentExport.branch).sort(([a], [b]) =>\n      compareStrings(a, b),\n    );\n    for (const [name, childExport] of entries) {\n      yield `${name}:`;\n      yield* codegenExport(ctx, analysis, childExport, componentPath);\n      yield \",\";\n    }\n    yield \"}\";\n  }\n}\n\nexport async function resolveFunctionReference(\n  ctx: Context,\n  analysis: EvaluatedComponentDefinition,\n  reference: Reference,\n  visibility: \"public\" | \"internal\",\n  componentPath: string | undefined,\n) {\n  if (!reference.startsWith(\"_reference/function/\")) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Invalid function reference: ${reference}`,\n    });\n  }\n  const udfPath = reference.slice(\"_reference/function/\".length);\n\n  const [modulePath, functionName] = udfPath.split(\":\");\n  const canonicalizedModulePath = canonicalizeModulePath(modulePath);\n\n  const analyzedModule = analysis.functions[canonicalizedModulePath];\n  if (!analyzedModule) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Module not found: ${modulePath}`,\n    });\n  }\n  const analyzedFunction = analyzedModule.functions.find(\n    (f) => f.name === functionName,\n  );\n  if (!analyzedFunction) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Function not found: ${functionName}`,\n    });\n  }\n  return await codegenFunctionReference(\n    ctx,\n    analyzedFunction,\n    visibility,\n    false,\n    componentPath,\n  );\n}\n\nasync function codegenFunctionReference(\n  ctx: Context,\n  analyzedFunction: AnalyzedFunction,\n  visibility: \"public\" | \"internal\",\n  useIdType: boolean,\n  componentPath: string | undefined,\n): Promise<string> {\n  // The server sends down `udfType` capitalized.\n  const udfType = analyzedFunction.udfType.toLowerCase();\n\n  let argsType = \"any\";\n  try {\n    const argsValidator = parseValidator(analyzedFunction.args);\n    if (argsValidator) {\n      if (argsValidator.type === \"object\" || argsValidator.type === \"any\") {\n        argsType = validatorToType(argsValidator, useIdType);\n      } else {\n        // eslint-disable-next-line no-restricted-syntax\n        throw new Error(\n          `Unexpected argument validator type: ${argsValidator.type}`,\n        );\n      }\n    }\n  } catch (e) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Invalid function args: ${analyzedFunction.args}`,\n      errForSentry: e,\n    });\n  }\n\n  let returnsType = \"any\";\n  try {\n    const returnsValidator = parseValidator(analyzedFunction.returns);\n    if (returnsValidator) {\n      returnsType = validatorToType(returnsValidator, useIdType);\n    }\n  } catch (e) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Invalid function returns: ${analyzedFunction.returns}`,\n      errForSentry: e,\n    });\n  }\n\n  return `FunctionReference<\"${udfType}\", \"${visibility}\", ${argsType}, ${returnsType}${componentPath ? `, ${componentPath}` : \"\"}>`;\n}\n\nfunction canonicalizeModulePath(modulePath: string): CanonicalizedModulePath {\n  if (!modulePath.endsWith(\".js\")) {\n    return modulePath + \".js\";\n  }\n  return modulePath;\n}\n"],
  "mappings": "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",
  "names": ["importPath", "path", "module", "name"]
}
