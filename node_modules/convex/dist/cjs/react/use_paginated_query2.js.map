{
  "version": 3,
  "sources": ["../../../src/react/use_paginated_query2.ts"],
  "sourcesContent": ["import { useState } from \"react\";\n\nimport { FunctionReference, getFunctionName } from \"../server/api.js\";\nimport {\n  PaginatedQueryReference,\n  PaginatedQueryArgs,\n  UsePaginatedQueryReturnType,\n} from \"./use_paginated_query.js\";\nimport { convexToJson, Value } from \"../values/value.js\";\nimport { useQueries } from \"./use_queries.js\";\nimport { PaginatedQueryResult } from \"../browser/sync/pagination.js\";\nimport { SubscribeToPaginatedQueryOptions } from \"../browser/sync/paginated_query_client.js\";\nimport { ConvexError } from \"../values/errors.js\";\nimport { useConvex } from \"./client.js\";\n\ntype UsePaginatedQueryState = {\n  query: FunctionReference<\"query\">;\n  args: Record<string, Value>;\n  id: number;\n  queries: {\n    paginatedQuery?: {\n      query: FunctionReference<\"query\">;\n      args: Record<string, Value>;\n      paginationOptions: SubscribeToPaginatedQueryOptions;\n    };\n  };\n  skip: boolean;\n};\n\n/**\n * Experimental new usePaginatedQuery implementation that will replace the current one\n * in the future.\n *\n * Load data reactively from a paginated query to a create a growing list.\n *\n * This is an alternate implementation that relies on new client pagination logic.\n *\n * This can be used to power \"infinite scroll\" UIs.\n *\n * This hook must be used with public query references that match\n * {@link PaginatedQueryReference}.\n *\n * `usePaginatedQuery` concatenates all the pages of results into a single list\n * and manages the continuation cursors when requesting more items.\n *\n * Example usage:\n * ```typescript\n * const { results, status, isLoading, loadMore } = usePaginatedQuery(\n *   api.messages.list,\n *   { channel: \"#general\" },\n *   { initialNumItems: 5 }\n * );\n * ```\n *\n * If the query reference or arguments change, the pagination state will be reset\n * to the first page. Similarly, if any of the pages result in an InvalidCursor\n * error or an error associated with too much data, the pagination state will also\n * reset to the first page.\n *\n * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/database/pagination).\n *\n * @param query - A FunctionReference to the public query function to run.\n * @param args - The arguments object for the query function, excluding\n * the `paginationOpts` property. That property is injected by this hook.\n * @param options - An object specifying the `initialNumItems` to be loaded in\n * the first page.\n * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded\n * items, the status of the pagination, and a `loadMore` function.\n *\n * @public\n */\nexport function usePaginatedQuery_experimental<\n  Query extends PaginatedQueryReference,\n>(\n  query: Query,\n  args: PaginatedQueryArgs<Query> | \"skip\",\n  // Future options this hook might accept:\n  // - maximumRowsRead\n  // - maximumBytesRead\n  // - a cursor for where to start? although probably no endCursor\n  options: { initialNumItems: number },\n): UsePaginatedQueryReturnType<Query> {\n  if (\n    typeof options?.initialNumItems !== \"number\" ||\n    options.initialNumItems < 0\n  ) {\n    throw new Error(\n      `\\`options.initialNumItems\\` must be a positive number. Received \\`${options?.initialNumItems}\\`.`,\n    );\n  }\n  const skip = args === \"skip\";\n  const argsObject = skip ? {} : args;\n\n  const convexClient = useConvex();\n  const logger = convexClient.logger;\n\n  // The identity of createInitialState changes each time!\n  const createInitialState: () => UsePaginatedQueryState = () => {\n    const id = nextPaginationId();\n    return {\n      query,\n      args: argsObject as Record<string, Value>,\n      id,\n      // Queries will contain zero or one queries forever.\n      queries: skip\n        ? ({} as UsePaginatedQueryState[\"queries\"])\n        : {\n            paginatedQuery: {\n              query,\n              args: {\n                ...argsObject,\n              },\n              paginationOptions: {\n                initialNumItems: options.initialNumItems,\n                id,\n              },\n            },\n          },\n      skip,\n    };\n  };\n\n  const [state, setState] =\n    useState<UsePaginatedQueryState>(createInitialState);\n\n  // `currState` is the state that we'll render based on.\n  let currState = state;\n  // New function, args, or skip? New paginated query!\n  if (\n    getFunctionName(query) !== getFunctionName(state.query) ||\n    JSON.stringify(convexToJson(argsObject as Value)) !==\n      JSON.stringify(convexToJson(state.args)) ||\n    skip !== state.skip\n  ) {\n    currState = createInitialState();\n    setState(currState);\n  }\n  // currState.queries is just a single query; we use useQueries\n  // because it's the lower-level ook sthat supports pagination options.\n  const resultsObject = useQueries(currState.queries);\n\n  // skip\n  if (!(\"paginatedQuery\" in resultsObject)) {\n    if (!skip) {\n      throw new Error(\"Why is it missing?\");\n    }\n    return {\n      results: [],\n      status: \"LoadingFirstPage\",\n      isLoading: true,\n      loadMore: function skipNOP(_numItems: number) {\n        return false;\n      },\n    };\n  }\n  const result = resultsObject.paginatedQuery as\n    | PaginatedQueryResult<Query[\"_returnType\"][\"page\"][number]>\n    | Error;\n\n  // TODO this is a weird mix of responsibilities:\n  // - is it the hook's job to render the initial loading state?\n  // - or is it the paginated query's job to render the approproate loading state?\n  // It comes back to why we'd ever get undefined when asking about a query; have we not yet called subscribe for it?\n  if (result === undefined) {\n    return {\n      results: [],\n      loadMore: () => false,\n      isLoading: true,\n      status: \"LoadingFirstPage\",\n    };\n  }\n\n  if (result instanceof Error) {\n    if (\n      result.message.includes(\"InvalidCursor\") ||\n      (result instanceof ConvexError &&\n        typeof result.data === \"object\" &&\n        result.data?.isConvexSystemError === true &&\n        result.data?.paginationError === \"InvalidCursor\")\n    ) {\n      // - InvalidCursor: If the cursor is invalid, probably the paginated\n      // database query was data-dependent and changed underneath us. The\n      // cursor in the params or journal no longer matches the current\n      // database query.\n\n      // In all cases, we want to restart pagination to throw away all our\n      // existing cursors.\n      logger.warn(\n        \"usePaginatedQuery hit error, resetting pagination state: \" +\n          result.message,\n      );\n      setState(createInitialState);\n      return {\n        results: [],\n        loadMore: () => false,\n        isLoading: true,\n        status: \"LoadingFirstPage\",\n      };\n    } else {\n      throw result;\n    }\n  }\n\n  return {\n    ...result,\n    loadMore: (num) => {\n      return result.loadMore(num);\n    },\n    isLoading:\n      result.status === \"LoadingFirstPage\"\n        ? true\n        : result.status === \"LoadingMore\"\n          ? true\n          : false,\n  } as UsePaginatedQueryReturnType<Query>;\n}\n\nlet paginationId = 0;\n/**\n * See ./use_paginated_query for the purpose, but we may be able to get rid of this soon.\n *\n * @returns The pagination ID.\n */\nfunction nextPaginationId(): number {\n  paginationId++;\n  return paginationId;\n}\n\n/**\n * Reset pagination id for tests only, so tests know what it is.\n */\nexport function resetPaginationId() {\n  paginationId = 0;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAyB;AAEzB,iBAAmD;AAMnD,mBAAoC;AACpC,yBAA2B;AAG3B,oBAA4B;AAC5B,oBAA0B;AA0DnB,SAAS,+BAGd,OACA,MAKA,SACoC;AACpC,MACE,OAAO,SAAS,oBAAoB,YACpC,QAAQ,kBAAkB,GAC1B;AACA,UAAM,IAAI;AAAA,MACR,qEAAqE,SAAS,eAAe;AAAA,IAC/F;AAAA,EACF;AACA,QAAM,OAAO,SAAS;AACtB,QAAM,aAAa,OAAO,CAAC,IAAI;AAE/B,QAAM,mBAAe,yBAAU;AAC/B,QAAM,SAAS,aAAa;AAG5B,QAAM,qBAAmD,MAAM;AAC7D,UAAM,KAAK,iBAAiB;AAC5B,WAAO;AAAA,MACL;AAAA,MACA,MAAM;AAAA,MACN;AAAA;AAAA,MAEA,SAAS,OACJ,CAAC,IACF;AAAA,QACE,gBAAgB;AAAA,UACd;AAAA,UACA,MAAM;AAAA,YACJ,GAAG;AAAA,UACL;AAAA,UACA,mBAAmB;AAAA,YACjB,iBAAiB,QAAQ;AAAA,YACzB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AAEA,QAAM,CAAC,OAAO,QAAQ,QACpB,uBAAiC,kBAAkB;AAGrD,MAAI,YAAY;AAEhB,UACE,4BAAgB,KAAK,UAAM,4BAAgB,MAAM,KAAK,KACtD,KAAK,cAAU,2BAAa,UAAmB,CAAC,MAC9C,KAAK,cAAU,2BAAa,MAAM,IAAI,CAAC,KACzC,SAAS,MAAM,MACf;AACA,gBAAY,mBAAmB;AAC/B,aAAS,SAAS;AAAA,EACpB;AAGA,QAAM,oBAAgB,+BAAW,UAAU,OAAO;AAGlD,MAAI,EAAE,oBAAoB,gBAAgB;AACxC,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,MAAM,oBAAoB;AAAA,IACtC;AACA,WAAO;AAAA,MACL,SAAS,CAAC;AAAA,MACV,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,UAAU,SAAS,QAAQ,WAAmB;AAC5C,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,QAAM,SAAS,cAAc;AAQ7B,MAAI,WAAW,QAAW;AACxB,WAAO;AAAA,MACL,SAAS,CAAC;AAAA,MACV,UAAU,MAAM;AAAA,MAChB,WAAW;AAAA,MACX,QAAQ;AAAA,IACV;AAAA,EACF;AAEA,MAAI,kBAAkB,OAAO;AAC3B,QACE,OAAO,QAAQ,SAAS,eAAe,KACtC,kBAAkB,6BACjB,OAAO,OAAO,SAAS,YACvB,OAAO,MAAM,wBAAwB,QACrC,OAAO,MAAM,oBAAoB,iBACnC;AAQA,aAAO;AAAA,QACL,8DACE,OAAO;AAAA,MACX;AACA,eAAS,kBAAkB;AAC3B,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,QACV,UAAU,MAAM;AAAA,QAChB,WAAW;AAAA,QACX,QAAQ;AAAA,MACV;AAAA,IACF,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,UAAU,CAAC,QAAQ;AACjB,aAAO,OAAO,SAAS,GAAG;AAAA,IAC5B;AAAA,IACA,WACE,OAAO,WAAW,qBACd,OACA,OAAO,WAAW,gBAChB,OACA;AAAA,EACV;AACF;AAEA,IAAI,eAAe;AAMnB,SAAS,mBAA2B;AAClC;AACA,SAAO;AACT;AAKO,SAAS,oBAAoB;AAClC,iBAAe;AACjB;",
  "names": []
}
