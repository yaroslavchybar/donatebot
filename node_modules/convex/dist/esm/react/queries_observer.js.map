{
  "version": 3,
  "sources": ["../../../src/react/queries_observer.ts"],
  "sourcesContent": ["import { convexToJson, Value } from \"../values/index.js\";\nimport { PaginatedWatch, Watch } from \"./client.js\";\nimport { QueryJournal } from \"../browser/sync/protocol.js\";\nimport { FunctionReference, getFunctionName } from \"../server/api.js\";\nimport { RequestForQueries } from \"./use_queries.js\";\nimport { PaginatedQueryResult } from \"../browser/sync/pagination.js\";\nimport { SubscribeToPaginatedQueryOptions } from \"../browser/sync/paginated_query_client.js\";\n\ntype Identifier = string;\n\ntype QueryInfo = {\n  query: FunctionReference<\"query\">;\n  args: Record<string, Value>;\n  watch: Watch<Value> | PaginatedWatch<Value>;\n  unsubscribe: () => void;\n  paginationOptions?: SubscribeToPaginatedQueryOptions;\n};\n\nexport interface CreateWatch {\n  (\n    query: FunctionReference<\"query\">,\n    args: Record<string, Value>,\n    options: {\n      journal?: QueryJournal;\n      // Just the existence of this option makes this a paginated query\n      paginationOptions?: SubscribeToPaginatedQueryOptions;\n    },\n  ): Watch<Value> | PaginatedWatch<Value>;\n}\n\n/**\n * A class for observing the results of multiple queries at the same time.\n *\n * Any time the result of a query changes, the listeners are notified.\n */\nexport class QueriesObserver {\n  public createWatch: CreateWatch;\n  private queries: Record<Identifier, QueryInfo>;\n  private listeners: Set<() => void>;\n\n  constructor(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    this.queries = {};\n    this.listeners = new Set();\n  }\n\n  setQueries(\n    newQueries: Record<\n      Identifier,\n      {\n        query: FunctionReference<\"query\">;\n        args: Record<string, Value>;\n        paginationOptions?: SubscribeToPaginatedQueryOptions;\n      }\n    >,\n  ) {\n    // Add the new queries before unsubscribing from the old ones so that\n    // the deduping in the `ConvexReactClient` can help if there are duplicates.\n    for (const identifier of Object.keys(newQueries)) {\n      const { query, args, paginationOptions } = newQueries[identifier];\n      // Might throw\n      getFunctionName(query);\n\n      if (this.queries[identifier] === undefined) {\n        // No existing query => add it.\n        this.addQuery(\n          identifier,\n          query,\n          args,\n          paginationOptions ? { paginationOptions } : {},\n        );\n      } else {\n        const existingInfo = this.queries[identifier];\n\n        if (\n          getFunctionName(query) !== getFunctionName(existingInfo.query) ||\n          JSON.stringify(convexToJson(args)) !==\n            JSON.stringify(convexToJson(existingInfo.args)) ||\n          JSON.stringify(paginationOptions) !==\n            JSON.stringify(existingInfo.paginationOptions)\n        ) {\n          // Existing query that doesn't match => remove the old and add the new.\n          this.removeQuery(identifier);\n          this.addQuery(\n            identifier,\n            query,\n            args,\n            paginationOptions ? { paginationOptions } : {},\n          );\n        }\n      }\n    }\n\n    // Prune all the existing queries that we no longer need.\n    for (const identifier of Object.keys(this.queries)) {\n      if (newQueries[identifier] === undefined) {\n        this.removeQuery(identifier);\n      }\n    }\n  }\n\n  subscribe(listener: () => void): () => void {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  getLocalResults(\n    queries: RequestForQueries,\n  ): Record<\n    Identifier,\n    Value | undefined | Error | PaginatedQueryResult<Value>\n  > {\n    const result: Record<\n      Identifier,\n      Value | Error | undefined | PaginatedQueryResult<Value>\n    > = {};\n    for (const identifier of Object.keys(queries)) {\n      const { query, args } = queries[identifier];\n      const paginationOptions = queries[identifier].paginationOptions;\n\n      // Might throw\n      getFunctionName(query);\n\n      // Note: We're not gonna watch, we could save some allocations\n      // by getting a reference to the client directly instead.\n      const watch = this.createWatch(\n        query,\n        args,\n        paginationOptions ? { paginationOptions } : {},\n      );\n\n      let value: Value | undefined | Error | PaginatedQueryResult<Value>;\n      try {\n        value = watch.localQueryResult();\n      } catch (e) {\n        // Only collect instances of `Error` because thats how callers\n        // will distinguish errors from normal results.\n        if (e instanceof Error) {\n          value = e;\n        } else {\n          throw e;\n        }\n      }\n      result[identifier] = value;\n    }\n    return result;\n  }\n\n  setCreateWatch(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    // If we have a new watch, we might be using a new Convex client.\n    // Recreate all the watches being careful to preserve the journals.\n    for (const identifier of Object.keys(this.queries)) {\n      const { query, args, watch, paginationOptions } =\n        this.queries[identifier];\n      const journal = \"journal\" in watch ? watch.journal() : undefined;\n      this.removeQuery(identifier);\n      this.addQuery(identifier, query, args, {\n        ...(journal ? { journal } : []),\n        ...(paginationOptions ? { paginationOptions } : {}),\n      });\n    }\n  }\n\n  destroy() {\n    for (const identifier of Object.keys(this.queries)) {\n      this.removeQuery(identifier);\n    }\n    this.listeners = new Set();\n  }\n\n  private addQuery(\n    identifier: Identifier,\n    query: FunctionReference<\"query\">,\n    args: Record<string, Value>,\n    {\n      paginationOptions,\n      journal,\n    }: {\n      paginationOptions?: SubscribeToPaginatedQueryOptions;\n      journal?: QueryJournal;\n    },\n  ) {\n    if (this.queries[identifier] !== undefined) {\n      throw new Error(\n        `Tried to add a new query with identifier ${identifier} when it already exists.`,\n      );\n    }\n    const watch = this.createWatch(query, args, {\n      ...(journal ? { journal } : []),\n      ...(paginationOptions ? { paginationOptions } : {}),\n    });\n    const unsubscribe = watch.onUpdate(() => this.notifyListeners());\n    this.queries[identifier] = {\n      query,\n      args,\n      watch,\n      unsubscribe,\n      ...(paginationOptions ? { paginationOptions } : {}),\n    };\n  }\n\n  private removeQuery(identifier: Identifier) {\n    const info = this.queries[identifier];\n    if (info === undefined) {\n      throw new Error(`No query found with identifier ${identifier}.`);\n    }\n    info.unsubscribe();\n    delete this.queries[identifier];\n  }\n\n  private notifyListeners(): void {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
