{
  "version": 3,
  "sources": ["../../../../src/cli/lib/codegen.ts"],
  "sourcesContent": ["import path from \"path\";\nimport prettier from \"prettier\";\nimport { withTmpDir, TempDir } from \"../../bundler/fs.js\";\nimport { entryPoints } from \"../../bundler/index.js\";\nimport { apiCodegen } from \"../codegen_templates/api.js\";\nimport { apiCjsCodegen } from \"../codegen_templates/api_cjs.js\";\nimport {\n  dynamicDataModelDTS,\n  dynamicDataModelTS,\n  noSchemaDataModelDTS,\n  noSchemaDataModelTS,\n  staticDataModelDTS,\n  staticDataModelTS,\n} from \"../codegen_templates/dataModel.js\";\nimport { readmeCodegen } from \"../codegen_templates/readme.js\";\nimport { serverCodegen } from \"../codegen_templates/server.js\";\nimport { tsconfigCodegen } from \"../codegen_templates/tsconfig.js\";\nimport { Context } from \"../../bundler/context.js\";\nimport {\n  logError,\n  logMessage,\n  logOutput,\n  logVerbose,\n} from \"../../bundler/log.js\";\nimport { typeCheckFunctionsInMode, TypeCheckMode } from \"./typecheck.js\";\nimport {\n  readProjectConfig,\n  usesTypeScriptCodegen,\n  usesComponentApiImports,\n} from \"./config.js\";\nimport { recursivelyDelete } from \"./fsUtils.js\";\nimport { componentServerTS } from \"../codegen_templates/component_server.js\";\nimport { ComponentDirectory } from \"./components/definition/directoryStructure.js\";\nimport { StartPushResponse } from \"./deployApi/startPush.js\";\nimport {\n  componentApiDTS,\n  componentApiJs,\n  componentApiStubDTS,\n  componentApiStubTS,\n  componentApiTSWithTypes,\n  componentTS,\n  rootComponentApiCJS,\n} from \"../codegen_templates/component_api.js\";\nimport { functionsDir } from \"./utils/utils.js\";\nimport { LargeIndexDeletionCheck } from \"./indexes.js\";\n\nexport type CodegenOptions = {\n  url?: string | undefined;\n  adminKey?: string | undefined;\n  dryRun: boolean;\n  debug: boolean;\n  typecheck: TypeCheckMode;\n  init: boolean;\n  commonjs: boolean;\n  liveComponentSources: boolean;\n  debugNodeApis: boolean;\n  systemUdfs: boolean;\n  largeIndexDeletionCheck: LargeIndexDeletionCheck;\n  codegenOnlyThisComponent?: string | undefined;\n};\n\nexport async function doInitConvexFolder(\n  ctx: Context,\n  functionsFolder?: string,\n  opts?: {\n    dryRun?: boolean;\n    debug?: boolean;\n  },\n) {\n  const skipIfExists = false; // Not currently configured\n  let folder: string;\n  if (functionsFolder) {\n    folder = functionsFolder;\n  } else {\n    const { projectConfig, configPath } = await readProjectConfig(ctx);\n    folder = functionsDir(configPath, projectConfig);\n  }\n  await prepareForCodegen(ctx, folder, opts);\n  await withTmpDir(async (tmpDir) => {\n    await doReadmeCodegen(ctx, tmpDir, folder, skipIfExists, opts);\n    await doTsconfigCodegen(ctx, tmpDir, folder, skipIfExists, opts);\n  });\n}\n\nasync function prepareForCodegen(\n  ctx: Context,\n  functionsDir: string,\n  opts?: { dryRun?: boolean },\n) {\n  // Delete the old _generated.ts because v0.1.2 used to put the react generated\n  // code there\n  const legacyCodegenPath = path.join(functionsDir, \"_generated.ts\");\n  if (ctx.fs.exists(legacyCodegenPath)) {\n    if (opts?.dryRun) {\n      logError(\n        `Command would delete legacy codegen file: ${legacyCodegenPath}}`,\n      );\n    } else {\n      logError(`Deleting legacy codegen file: ${legacyCodegenPath}}`);\n      ctx.fs.unlink(legacyCodegenPath);\n    }\n  }\n\n  // Create the codegen dir if it doesn't already exist.\n  const codegenDir = path.join(functionsDir, \"_generated\");\n  ctx.fs.mkdir(codegenDir, { allowExisting: true, recursive: true });\n  return codegenDir;\n}\n\n/** Codegen only for an application (a root component) */\nexport async function doCodegen(\n  ctx: Context,\n  functionsDir: string,\n  typeCheckMode: TypeCheckMode,\n  opts?: { dryRun?: boolean; generateCommonJSApi?: boolean; debug?: boolean },\n) {\n  const { projectConfig } = await readProjectConfig(ctx);\n  const codegenDir = await prepareForCodegen(ctx, functionsDir, opts);\n\n  await withTmpDir(async (tmpDir) => {\n    // Write files in dependency order so a watching dev server doesn't\n    // see inconsistent results where a file we write imports from a\n    // file that doesn't exist yet. We'll collect all the paths we write\n    // and then delete any remaining paths at the end.\n    const writtenFiles = [];\n\n    const useTypeScript = usesTypeScriptCodegen(projectConfig);\n    const generateCommonJSApi =\n      opts?.generateCommonJSApi || projectConfig.generateCommonJSApi;\n\n    // First, `dataModel.d.ts` imports from the developer's `schema.js` file.\n    const schemaFiles = await doDataModelCodegen(\n      ctx,\n      tmpDir,\n      functionsDir,\n      codegenDir,\n      useTypeScript,\n      opts,\n    );\n    writtenFiles.push(...schemaFiles);\n\n    // Next, the `server.d.ts` file imports from `dataModel.d.ts`.\n    const serverFiles = await writeServerFiles(\n      ctx,\n      tmpDir,\n      codegenDir,\n      useTypeScript,\n      opts,\n    );\n    writtenFiles.push(...serverFiles);\n\n    // The `api.d.ts` file imports from the developer's modules, which then\n    // import from `server.d.ts`. Note that there's a cycle here, since the\n    // developer's modules could also import from the `api.{js,d.ts}` files.\n    const apiFiles = await doApiCodegen(\n      ctx,\n      tmpDir,\n      functionsDir,\n      codegenDir,\n      useTypeScript,\n      generateCommonJSApi,\n      opts,\n    );\n    writtenFiles.push(...apiFiles);\n\n    // Cleanup any files that weren't written in this run.\n    // Skip cleanup in debug mode since we don't actually write files in that mode.\n    if (!opts?.debug) {\n      for (const file of ctx.fs.listDir(codegenDir)) {\n        if (!writtenFiles.includes(file.name)) {\n          recursivelyDelete(ctx, path.join(codegenDir, file.name), opts);\n        }\n      }\n    }\n\n    // Generated code is updated, typecheck the query and mutation functions.\n    await typeCheckFunctionsInMode(ctx, typeCheckMode, functionsDir);\n  });\n}\n\n// Just enough to be able to bundle code for analysis: we need an api proxy object\n// so that imports aren't broken, we need basics in server, we need something in\n// data model.\nexport async function doInitialComponentCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  componentDirectory: ComponentDirectory,\n  opts?: {\n    dryRun?: boolean;\n    generateCommonJSApi?: boolean;\n    debug?: boolean;\n    verbose?: boolean;\n  },\n) {\n  const { projectConfig } = await readProjectConfig(ctx);\n\n  if (isPublishedPackage(componentDirectory)) {\n    if (opts?.verbose) {\n      logMessage(\n        `skipping initial codegen for installed package ${componentDirectory.path}`,\n      );\n    }\n    return;\n  }\n\n  const codegenDir = await prepareForCodegen(\n    ctx,\n    componentDirectory.path,\n    opts,\n  );\n\n  // Write files in dependency order so a watching dev server doesn't\n  // see inconsistent results where a file we write imports from a\n  // file that doesn't exist yet. We'll collect all the paths we write\n  // and then delete any remaining paths at the end.\n  const writtenFiles = [];\n\n  // Non-root components always use .ts files; root components respect the config\n  // But for initial (placeholder, stub) codegen we don't care, just use .d.ts and .js.\n  const useTypeScript =\n    !componentDirectory.isRoot || usesTypeScriptCodegen(projectConfig);\n\n  const generateCommonJSApi =\n    opts?.generateCommonJSApi || projectConfig.generateCommonJSApi;\n\n  // First, `dataModel.d.ts` imports from the developer's `schema.js` file.\n  const dataModelFiles = await doInitialComponentDataModelCodegen(\n    ctx,\n    tmpDir,\n    componentDirectory,\n    codegenDir,\n    useTypeScript,\n    opts,\n  );\n  writtenFiles.push(...dataModelFiles);\n\n  // Next, the `server.d.ts` file imports from `dataModel.d.ts`.\n  const serverFiles = await doInitialComponentServerCodegen(\n    ctx,\n    componentDirectory.isRoot,\n    tmpDir,\n    codegenDir,\n    useTypeScript,\n    opts,\n  );\n  writtenFiles.push(...serverFiles);\n\n  // The `api.d.ts` file imports from the developer's modules, which then\n  // import from `server.d.ts`. Note that there's a cycle here, since the\n  // developer's modules could also import from the `api.{js,d.ts}` files.\n  const apiFiles = await doInitialComponentApiCodegen(\n    ctx,\n    componentDirectory.isRoot,\n    tmpDir,\n    codegenDir,\n    useTypeScript,\n    generateCommonJSApi,\n    opts,\n  );\n  writtenFiles.push(...apiFiles);\n\n  // component.ts is generated in doFinalComponentCodegen, but don't delete\n  // if it already exists from a previous full codegen run.\n  if (!componentDirectory.isRoot) {\n    const componentTSPath = path.join(codegenDir, \"component.ts\");\n    if (ctx.fs.exists(componentTSPath)) {\n      writtenFiles.push(\"component.ts\");\n    }\n  }\n\n  // Cleanup any files that weren't written in this run.\n  // Skip cleanup in debug mode since we don't actually write files in that mode.\n  if (!opts?.debug) {\n    for (const file of ctx.fs.listDir(codegenDir)) {\n      if (!writtenFiles.includes(file.name)) {\n        recursivelyDelete(ctx, path.join(codegenDir, file.name), opts);\n      }\n    }\n  }\n}\n\n/* This component defined in a dist directory; it is probably in a node_module\n * directory, installed from a package. It is stuck with the files it has.\n * Heuristics for this:\n * - component definition has a dist/ directory as an ancestor\n * - component definition is a .js file\n * - presence of .js.map files\n * We may improve this heuristic.\n */\nexport function isPublishedPackage(componentDirectory: ComponentDirectory) {\n  return (\n    componentDirectory.definitionPath.endsWith(\".js\") &&\n    !componentDirectory.isRoot\n  );\n}\n\n// Handles root and non-root components; it's \"component\" codegen because\n// it's not the old legacy path.\nexport async function doFinalComponentCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  rootComponent: ComponentDirectory,\n  componentDirectory: ComponentDirectory,\n  startPushResponse: StartPushResponse,\n  componentsMap: Map<string, ComponentDirectory>,\n  opts?: {\n    dryRun?: boolean;\n    debug?: boolean;\n    generateCommonJSApi?: boolean;\n  },\n) {\n  const { projectConfig } = await readProjectConfig(ctx);\n\n  const isPublishedPackage =\n    componentDirectory.definitionPath.endsWith(\".js\") &&\n    !componentDirectory.isRoot;\n  // We never codegen for a published package (you need to link to the convex.config.ts file instead).\n  if (isPublishedPackage) {\n    return;\n  }\n\n  const codegenDir = path.join(componentDirectory.path, \"_generated\");\n  ctx.fs.mkdir(codegenDir, { allowExisting: true, recursive: true });\n\n  // Non-root components always use .ts files; root components respect the config\n  const useTypeScript =\n    !componentDirectory.isRoot || usesTypeScriptCodegen(projectConfig);\n\n  // `dataModel` and `api` files depend on analyze results so will get replaced\n  // in the later post-analysis codegen phase,  but `server` files don't need\n  // analysis info so the stubs from initial codegen are sufficient.\n\n  // dataModel\n  const hasSchemaFile = schemaFileExists(ctx, componentDirectory.path);\n  let dataModelContents: string;\n  if (hasSchemaFile) {\n    if (projectConfig.codegen.staticDataModel) {\n      dataModelContents = useTypeScript\n        ? await staticDataModelTS(\n            ctx,\n            startPushResponse,\n            rootComponent,\n            componentDirectory,\n          )\n        : await staticDataModelDTS(\n            ctx,\n            startPushResponse,\n            rootComponent,\n            componentDirectory,\n          );\n    } else {\n      dataModelContents = useTypeScript\n        ? dynamicDataModelTS()\n        : dynamicDataModelDTS();\n    }\n  } else {\n    dataModelContents = useTypeScript\n      ? noSchemaDataModelTS()\n      : noSchemaDataModelDTS();\n  }\n  const dataModelPath = path.join(\n    codegenDir,\n    useTypeScript ? \"dataModel.ts\" : \"dataModel.d.ts\",\n  );\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    dataModelContents,\n    \"typescript\",\n    dataModelPath,\n    opts,\n  );\n\n  // component.ts\n  if (!componentDirectory.isRoot) {\n    const componentTSPath = path.join(codegenDir, \"component.ts\");\n    const componentTSContents = await componentTS(\n      ctx,\n      startPushResponse,\n      rootComponent,\n      componentDirectory,\n    );\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      componentTSContents,\n      \"typescript\",\n      componentTSPath,\n      opts,\n    );\n  }\n\n  // server.ts - regenerate it in final codegen for consistency, even though\n  // the stub from initial codegen would be sufficient.\n  await writeServerFilesForComponent(\n    ctx,\n    componentDirectory.isRoot,\n    tmpDir,\n    codegenDir,\n    useTypeScript,\n    opts,\n  );\n\n  // api\n  if (!useTypeScript) {\n    const apiDTSPath = path.join(codegenDir, \"api.d.ts\");\n    const apiContents = await componentApiDTS(\n      ctx,\n      startPushResponse,\n      rootComponent,\n      componentDirectory,\n      componentsMap,\n      {\n        staticApi: projectConfig.codegen.staticApi,\n        useComponentApiImports: usesComponentApiImports(projectConfig),\n      },\n    );\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      apiContents,\n      \"typescript\",\n      apiDTSPath,\n      opts,\n    );\n\n    if (opts?.generateCommonJSApi || projectConfig.generateCommonJSApi) {\n      const apiCjsDTSPath = path.join(codegenDir, \"api_cjs.d.cts\");\n      await writeFormattedFile(\n        ctx,\n        tmpDir,\n        apiContents,\n        \"typescript\",\n        apiCjsDTSPath,\n        opts,\n      );\n    }\n  } else {\n    const apiTSPath = path.join(codegenDir, \"api.ts\");\n    const apiContents = await componentApiTSWithTypes(\n      ctx,\n      startPushResponse,\n      rootComponent,\n      componentDirectory,\n      componentsMap,\n      {\n        staticApi: projectConfig.codegen.staticApi,\n        useComponentApiImports: usesComponentApiImports(projectConfig),\n      },\n    );\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      apiContents,\n      \"typescript\",\n      apiTSPath,\n      opts,\n    );\n  }\n}\n\nasync function doReadmeCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  functionsDir: string,\n  skipIfExists: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const readmePath = path.join(functionsDir, \"README.md\");\n  if (skipIfExists && ctx.fs.exists(readmePath)) {\n    logVerbose(`Not overwriting README.md.`);\n    return;\n  }\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    readmeCodegen(),\n    \"markdown\",\n    readmePath,\n    opts,\n  );\n}\n\nasync function doTsconfigCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  functionsDir: string,\n  skipIfExists: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const tsconfigPath = path.join(functionsDir, \"tsconfig.json\");\n  if (skipIfExists && ctx.fs.exists(tsconfigPath)) {\n    logVerbose(`Not overwriting tsconfig.json.`);\n    return;\n  }\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    tsconfigCodegen(),\n    \"json\",\n    tsconfigPath,\n    opts,\n  );\n}\n\nfunction schemaFileExists(ctx: Context, functionsDir: string) {\n  let schemaPath = path.join(functionsDir, \"schema.ts\");\n  let hasSchemaFile = ctx.fs.exists(schemaPath);\n  if (!hasSchemaFile) {\n    schemaPath = path.join(functionsDir, \"schema.js\");\n    hasSchemaFile = ctx.fs.exists(schemaPath);\n  }\n  return hasSchemaFile;\n}\n\nasync function doDataModelCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  functionsDir: string,\n  codegenDir: string,\n  useTypeScript: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const hasSchemaFile = schemaFileExists(ctx, functionsDir);\n  const schemaContent = hasSchemaFile\n    ? useTypeScript\n      ? dynamicDataModelTS()\n      : dynamicDataModelDTS()\n    : useTypeScript\n      ? noSchemaDataModelTS()\n      : noSchemaDataModelDTS();\n\n  const filename = useTypeScript ? \"dataModel.ts\" : \"dataModel.d.ts\";\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    schemaContent,\n    \"typescript\",\n    path.join(codegenDir, filename),\n    opts,\n  );\n  return [filename];\n}\n\n/**\n * Write server.ts/.js/.d.ts files for root components.\n * Returns list of filenames written.\n */\nasync function writeServerFiles(\n  ctx: Context,\n  tmpDir: TempDir,\n  codegenDir: string,\n  useTypeScript: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n): Promise<string[]> {\n  if (!useTypeScript) {\n    const serverContent = serverCodegen({ useTypeScript: false });\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      serverContent.JS!,\n      \"typescript\",\n      path.join(codegenDir, \"server.js\"),\n      opts,\n    );\n\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      serverContent.DTS!,\n      \"typescript\",\n      path.join(codegenDir, \"server.d.ts\"),\n      opts,\n    );\n\n    return [\"server.js\", \"server.d.ts\"];\n  } else {\n    const serverContent = serverCodegen({ useTypeScript: true });\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      serverContent.TS!,\n      \"typescript\",\n      path.join(codegenDir, \"server.ts\"),\n      opts,\n    );\n\n    return [\"server.ts\"];\n  }\n}\n\n/**\n * Write server.ts file for non-root components.\n * Returns list of filenames written.\n */\nasync function writeComponentServerFile(\n  ctx: Context,\n  tmpDir: TempDir,\n  codegenDir: string,\n  opts?: { dryRun?: boolean; debug?: boolean },\n): Promise<string[]> {\n  const serverTSPath = path.join(codegenDir, \"server.ts\");\n  const serverTSContents = componentServerTS(false);\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    serverTSContents,\n    \"typescript\",\n    serverTSPath,\n    opts,\n  );\n  return [\"server.ts\"];\n}\n\n/**\n * Write server files for either root or non-root components.\n * Root components get server.ts/server.js/server.d.ts based on useTypeScript.\n * Non-root components always get server.ts.\n * Returns list of filenames written.\n */\nasync function writeServerFilesForComponent(\n  ctx: Context,\n  isRoot: boolean,\n  tmpDir: TempDir,\n  codegenDir: string,\n  useTypeScript: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n): Promise<string[]> {\n  if (isRoot) {\n    return await writeServerFiles(ctx, tmpDir, codegenDir, useTypeScript, opts);\n  } else {\n    return await writeComponentServerFile(ctx, tmpDir, codegenDir, opts);\n  }\n}\n\nasync function doInitialComponentServerCodegen(\n  ctx: Context,\n  isRoot: boolean,\n  tmpDir: TempDir,\n  codegenDir: string,\n  useTypeScript: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  return await writeServerFilesForComponent(\n    ctx,\n    isRoot,\n    tmpDir,\n    codegenDir,\n    useTypeScript,\n    opts,\n  );\n}\n\nasync function doInitialComponentDataModelCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  componentDirectory: ComponentDirectory,\n  codegenDir: string,\n  useTypeScript: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const hasSchemaFile = schemaFileExists(ctx, componentDirectory.path);\n  const dataModelContent = hasSchemaFile\n    ? useTypeScript\n      ? dynamicDataModelTS()\n      : dynamicDataModelDTS()\n    : useTypeScript\n      ? noSchemaDataModelTS()\n      : noSchemaDataModelDTS();\n  const filename = useTypeScript ? \"dataModel.ts\" : \"dataModel.d.ts\";\n  const dataModelPath = path.join(codegenDir, filename);\n\n  // Don't write our stub if the file already exists, since it may have\n  // better type information from `doFinalComponentDataModelCodegen`.\n  if (!ctx.fs.exists(dataModelPath)) {\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      dataModelContent,\n      \"typescript\",\n      dataModelPath,\n      opts,\n    );\n  }\n  return [filename];\n}\n\nasync function doInitialComponentApiCodegen(\n  ctx: Context,\n  isRoot: boolean,\n  tmpDir: TempDir,\n  codegenDir: string,\n  useTypeScript: boolean,\n  generateCommonJSApi: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const writtenFiles: string[] = [];\n\n  if (!useTypeScript) {\n    const apiJS = componentApiJs();\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      apiJS,\n      \"typescript\",\n      path.join(codegenDir, \"api.js\"),\n      opts,\n    );\n\n    // Don't write the `.d.ts` stub if it already exists.\n    const apiDTSPath = path.join(codegenDir, \"api.d.ts\");\n    const apiStubDTS = componentApiStubDTS();\n    if (!ctx.fs.exists(apiDTSPath)) {\n      await writeFormattedFile(\n        ctx,\n        tmpDir,\n        apiStubDTS,\n        \"typescript\",\n        apiDTSPath,\n        opts,\n      );\n    }\n\n    writtenFiles.push(\"api.js\", \"api.d.ts\");\n\n    if (generateCommonJSApi && isRoot) {\n      const apiCjsJS = rootComponentApiCJS();\n      await writeFormattedFile(\n        ctx,\n        tmpDir,\n        apiCjsJS,\n        \"typescript\",\n        path.join(codegenDir, \"api_cjs.cjs\"),\n        opts,\n      );\n\n      const cjsStubPath = path.join(codegenDir, \"api_cjs.d.cts\");\n      if (!ctx.fs.exists(cjsStubPath)) {\n        await writeFormattedFile(\n          ctx,\n          tmpDir,\n          apiStubDTS,\n          \"typescript\",\n          cjsStubPath,\n          opts,\n        );\n      }\n      writtenFiles.push(\"api_cjs.cjs\", \"api_cjs.d.cts\");\n    }\n  } else {\n    const apiTSPath = path.join(codegenDir, \"api.ts\");\n    const apiTS = componentApiStubTS();\n    // Don't write the `.ts` stub if it already exists.\n    if (!ctx.fs.exists(apiTSPath)) {\n      await writeFormattedFile(\n        ctx,\n        tmpDir,\n        apiTS,\n        \"typescript\",\n        apiTSPath,\n        opts,\n      );\n    }\n    writtenFiles.push(\"api.ts\");\n  }\n\n  return writtenFiles;\n}\n\nasync function doApiCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  functionsDir: string,\n  codegenDir: string,\n  useTypeScript: boolean,\n  generateCommonJSApi: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const absModulePaths = await entryPoints(ctx, functionsDir);\n  const modulePaths = absModulePaths\n    .map((p) => path.relative(functionsDir, p))\n    .sort();\n\n  const writtenFiles: string[] = [];\n\n  if (!useTypeScript) {\n    const apiContent = apiCodegen(modulePaths, { useTypeScript: false });\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      apiContent.JS!,\n      \"typescript\",\n      path.join(codegenDir, \"api.js\"),\n      opts,\n    );\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      apiContent.DTS!,\n      \"typescript\",\n      path.join(codegenDir, \"api.d.ts\"),\n      opts,\n    );\n    writtenFiles.push(\"api.js\", \"api.d.ts\");\n\n    if (generateCommonJSApi) {\n      const apiCjsContent = apiCjsCodegen(modulePaths);\n      await writeFormattedFile(\n        ctx,\n        tmpDir,\n        apiCjsContent.JS!,\n        \"typescript\",\n        path.join(codegenDir, \"api_cjs.cjs\"),\n        opts,\n      );\n      await writeFormattedFile(\n        ctx,\n        tmpDir,\n        apiCjsContent.DTS!,\n        \"typescript\",\n        path.join(codegenDir, \"api_cjs.d.cts\"),\n        opts,\n      );\n      writtenFiles.push(\"api_cjs.cjs\", \"api_cjs.d.cts\");\n    }\n  } else {\n    const apiContent = apiCodegen(modulePaths, { useTypeScript: true });\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      apiContent.TS!,\n      \"typescript\",\n      path.join(codegenDir, \"api.ts\"),\n      opts,\n    );\n    writtenFiles.push(\"api.ts\");\n  }\n\n  return writtenFiles;\n}\n\nasync function writeFormattedFile(\n  ctx: Context,\n  tmpDir: TempDir,\n  contents: string,\n  filetype: string,\n  destination: string,\n  options?: {\n    dryRun?: boolean;\n    debug?: boolean;\n  },\n) {\n  // Run prettier so we don't have to think about formatting!\n  //\n  // This is a little sketchy because we are using the default prettier config\n  // (not our user's one) but it's better than nothing.\n  const formattedContents = await prettier.format(contents, {\n    parser: filetype,\n    pluginSearchDirs: false,\n  });\n  if (options?.debug) {\n    // NB: The `test_codegen_projects_are_up_to_date` smoke test depends\n    // on this output format.\n    logOutput(`# ${path.resolve(destination)}`);\n    logOutput(formattedContents);\n    return;\n  }\n  try {\n    const existing = ctx.fs.readUtf8File(destination);\n    if (existing === formattedContents) {\n      return;\n    }\n  } catch (err: any) {\n    if (err.code !== \"ENOENT\") {\n      // eslint-disable-next-line no-restricted-syntax\n      throw err;\n    }\n  }\n  if (options?.dryRun) {\n    logOutput(`Command would write file: ${destination}`);\n    return;\n  }\n  const tmpPath = tmpDir.writeUtf8File(formattedContents);\n  ctx.fs.swapTmpFile(tmpPath, destination);\n}\n"],
  "mappings": "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",
  "names": ["functionsDir", "isPublishedPackage"]
}
