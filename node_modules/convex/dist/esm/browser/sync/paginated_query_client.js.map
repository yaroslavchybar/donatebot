{
  "version": 3,
  "sources": ["../../../../src/browser/sync/paginated_query_client.ts"],
  "sourcesContent": ["/**\n * PaginatedQueryClient maps subscriptions to paginated queries to the\n * individual page queries and handles page splits.\n *\n * In order to process all modified queries, paginated and normal, in the same\n * synchronous call the PaginatedQueryClient transition should be used exclusively.\n *\n * Like the BaseConvexClient, this client is not Convex Function type-aware: it deals\n * with queries as functions that return Value, not the specific value.\n * Use a higher-level library to get types.\n */\n\nimport { Value } from \"../../values/index.js\";\nimport {\n  PaginatedQueryToken,\n  QueryToken,\n  serializePaginatedPathAndArgs,\n  canonicalizeUdfPath,\n} from \"./udf_path_utils.js\";\nimport { BaseConvexClient, Transition } from \"./client.js\";\nimport {\n  PaginatedQueryResult,\n  PaginationStatus,\n  asPaginationResult,\n} from \"./pagination.js\";\nimport { TS } from \"./protocol.js\";\nimport { Long } from \"../../vendor/long.js\";\n\ntype QueryPageKey = number;\n\n/**\n * Represents a paginated query subscription with multiple pages.\n *\n * To know the order of pages it's necessary to consult `pageKeys`.\n * The pages in this array are active, they constitute a gapless sequence of results.\n * Some pages are not in this array: they may be waiting for data for a page split.\n */\ntype LocalPaginatedQuery = {\n  token: PaginatedQueryToken;\n  canonicalizedUdfPath: string;\n  args: Record<string, Value>; // WITHOUT paginationOpts\n  numSubscribers: number;\n  options: { initialNumItems: number };\n  nextPageKey: QueryPageKey;\n  pageKeys: QueryPageKey[]; // These pages make up the active page queries.\n  // Map page keys to their query subscriptions\n  pageKeyToQuery: Map<\n    QueryPageKey,\n    { queryToken: QueryToken; unsubscribe: () => void }\n  >;\n  ongoingSplits: Map<QueryPageKey, [QueryPageKey, QueryPageKey]>;\n  skip: boolean;\n\n  // Give separate uses of the query separate identities,\n  // which may be removed in the future to improve caching.\n  id: number;\n};\n\nexport interface SubscribeToPaginatedQueryOptions {\n  initialNumItems: number;\n  id: number;\n}\n\ntype AnyPaginatedQueryResult = PaginatedQueryResult<Value>;\n\nexport type PaginatedQueryModification =\n  | { kind: \"Updated\"; result: AnyPaginatedQueryResult | undefined }\n  | { kind: \"Removed\" };\n\nexport type ExtendedTransition = Transition & {\n  paginatedQueries: Array<{\n    token: PaginatedQueryToken;\n    modification: PaginatedQueryModification;\n  }>;\n};\n\nexport class PaginatedQueryClient {\n  private paginatedQuerySet: Map<PaginatedQueryToken, LocalPaginatedQuery> =\n    new Map();\n  // hold onto a real Transition so we can construct synthetic ones with that timestamp\n  private lastTransitionTs: TS;\n\n  constructor(\n    private client: BaseConvexClient,\n    private onTransition: (transition: ExtendedTransition) => void,\n  ) {\n    // Nonsense initial value to construct synthetic Transitions\n    this.lastTransitionTs = Long.fromNumber(0);\n    this.client.addOnTransitionHandler((transition: Transition) =>\n      this.onBaseTransition(transition),\n    );\n  }\n\n  /**\n   * Subscribe to a paginated query.\n   *\n   * @param name - The name of the paginated query function\n   * @param args - Arguments for the query (excluding paginationOpts)\n   * @param options - Pagination options including initialNumItems\n   * @returns Object with paginatedQueryToken and unsubscribe function\n   */\n  subscribe(\n    name: string,\n    args: Record<string, Value>,\n    options: SubscribeToPaginatedQueryOptions,\n  ): {\n    paginatedQueryToken: PaginatedQueryToken;\n    unsubscribe: () => void;\n  } {\n    const canonicalizedUdfPath = canonicalizeUdfPath(name);\n    // Note that only the expected options are included in the serialization.\n    const token = serializePaginatedPathAndArgs(\n      canonicalizedUdfPath,\n      args,\n      options,\n    );\n\n    const unsubscribe = () => this.removePaginatedQuerySubscriber(token);\n\n    const existingEntry = this.paginatedQuerySet.get(token);\n    if (existingEntry) {\n      existingEntry.numSubscribers += 1;\n      return {\n        paginatedQueryToken: token,\n        unsubscribe,\n      };\n    }\n\n    // Create new paginated query\n    this.paginatedQuerySet.set(token, {\n      token,\n      canonicalizedUdfPath,\n      args,\n      numSubscribers: 1,\n      options: { initialNumItems: options.initialNumItems },\n      nextPageKey: 0,\n      pageKeys: [],\n      pageKeyToQuery: new Map(),\n      ongoingSplits: new Map(),\n      skip: false,\n      id: options.id,\n    });\n\n    this.addPageToPaginatedQuery(token, null, options.initialNumItems);\n\n    return {\n      paginatedQueryToken: token,\n      unsubscribe,\n    };\n  }\n\n  /**\n   * Get current results for a paginated query based on local state.\n   *\n   * Throws an error when one of the pages has errored.\n   */\n  localQueryResult(\n    name: string,\n    args: Record<string, Value>,\n    options: { initialNumItems: number; id: number },\n  ): AnyPaginatedQueryResult | undefined {\n    const canonicalizedUdfPath = canonicalizeUdfPath(name);\n    const token = serializePaginatedPathAndArgs(\n      canonicalizedUdfPath,\n      args,\n      options,\n    );\n    return this.localQueryResultByToken(token);\n  }\n\n  /**\n   * @internal\n   */\n  localQueryResultByToken(\n    token: PaginatedQueryToken,\n  ): AnyPaginatedQueryResult | undefined {\n    // undefined is probably the wrong value! Should be a real paginated query result for loading!\n    // Butit's confusing why we'd ever get this, I guess some flows call localQueryResult before\n    // subscribing? That's proabbly fair but is it consistent with the normal client?\n    // What is the invariant here, will a token always exist? Or can a lookup occur at any time?\n    const paginatedQuery = this.paginatedQuerySet.get(token);\n    if (!paginatedQuery) {\n      return undefined;\n    }\n\n    const activePages = this.activePageQueryTokens(paginatedQuery);\n    if (activePages.length === 0) {\n      return {\n        results: [],\n        status: \"LoadingFirstPage\",\n        loadMore: (numItems: number) => {\n          return this.loadMoreOfPaginatedQuery(token, numItems);\n        },\n      };\n    }\n\n    let allResults: Value[] = [];\n\n    // Some page is loading (this isn't supposed to happen to any page but the last)\n    let hasUndefined = false;\n    let isDone = false;\n\n    for (const pageToken of activePages) {\n      // This throws, don't catch it, it should bubble up.\n      // It might be a InvalidCursor Error. If it is, this query\n      // should be reset (for now, use a new ID to ensure new state).\n      //\n      // In the future this might be caught and dealt with here but\n      // an ID-based solution won't work here, ID is an intrinsic property\n      // of this paginated query.\n      const result = this.client.localQueryResultByToken(pageToken);\n\n      if (result === undefined) {\n        hasUndefined = true;\n        isDone = false;\n        continue;\n      }\n\n      const paginationResult = asPaginationResult(result);\n      allResults = allResults.concat(paginationResult.page);\n      // logic only relevant to the last page, we just happen to run it each time\n      isDone = !!paginationResult.isDone;\n    }\n\n    let status: PaginationStatus;\n    if (hasUndefined) {\n      status = allResults.length === 0 ? \"LoadingFirstPage\" : \"LoadingMore\";\n    } else if (isDone) {\n      status = \"Exhausted\";\n    } else {\n      status = \"CanLoadMore\";\n    }\n\n    return {\n      results: allResults,\n      status,\n      loadMore: (numItems: number) => {\n        return this.loadMoreOfPaginatedQuery(token, numItems);\n      },\n    };\n  }\n\n  private onBaseTransition(transition: Transition) {\n    const changedBaseTokens = transition.queries.map((q) => q.token);\n    const changed = this.queriesContainingTokens(changedBaseTokens);\n\n    let paginatedQueries: Array<{\n      token: PaginatedQueryToken;\n      modification: PaginatedQueryModification;\n    }> = [];\n\n    if (changed.length > 0) {\n      this.processPaginatedQuerySplits(changed, (token) =>\n        this.client.localQueryResultByToken(token),\n      );\n\n      paginatedQueries = changed.map((token) => ({\n        token,\n        modification: {\n          kind: \"Updated\" as const,\n          result: this.localQueryResultByToken(token),\n        },\n      }));\n    }\n\n    const extendedTransition: ExtendedTransition = {\n      ...transition,\n      paginatedQueries,\n    };\n\n    this.onTransition(extendedTransition);\n  }\n\n  /**\n   * Load more items for a paginated query.\n   *\n   * This *always* causes a transition, the status of the query\n   * has probably changed from \"CanLoadMore\" to \"LoadingMore\".\n   * Data might have changed too: maybe a subscription to this page\n   * query already exists (unlikely but possible) or this page query\n   * has an optimistic update providing some initial data.\n   *\n   * @internal\n   */\n  private loadMoreOfPaginatedQuery(\n    token: PaginatedQueryToken,\n    numItems: number,\n  ): boolean {\n    this.mustGetPaginatedQuery(token);\n\n    const lastPageToken = this.queryTokenForLastPageOfPaginatedQuery(token);\n    const lastPageResult = this.client.localQueryResultByToken(lastPageToken);\n\n    if (!lastPageResult) {\n      // Still loading a page and concurrent loads are not allowed\n      return false;\n    }\n\n    const paginationResult = asPaginationResult(lastPageResult);\n    if (paginationResult.isDone) {\n      // No more pages available\n      return false;\n    }\n\n    this.addPageToPaginatedQuery(\n      token,\n      paginationResult.continueCursor,\n      numItems,\n    );\n\n    const loadMoreTransition: ExtendedTransition = {\n      timestamp: this.lastTransitionTs,\n      reflectedMutations: [],\n      queries: [],\n      paginatedQueries: [\n        {\n          token,\n          modification: {\n            kind: \"Updated\" as const,\n            result: this.localQueryResultByToken(token),\n          },\n        },\n      ],\n    };\n    this.onTransition(loadMoreTransition);\n\n    return true;\n  }\n\n  /**\n   * @internal\n   */\n  private queriesContainingTokens(\n    queryTokens: QueryToken[],\n  ): PaginatedQueryToken[] {\n    if (queryTokens.length === 0) {\n      return [];\n    }\n\n    const changed: PaginatedQueryToken[] = [];\n    const queryTokenSet = new Set(queryTokens);\n\n    for (const [paginatedToken, paginatedQuery] of this.paginatedQuerySet) {\n      for (const pageToken of this.allQueryTokens(paginatedQuery)) {\n        if (queryTokenSet.has(pageToken)) {\n          changed.push(paginatedToken);\n          break;\n        }\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n   * @internal\n   */\n  private processPaginatedQuerySplits(\n    changed: PaginatedQueryToken[],\n    getResult: (token: QueryToken) => Value | undefined,\n  ): void {\n    for (const paginatedQueryToken of changed) {\n      const paginatedQuery = this.mustGetPaginatedQuery(paginatedQueryToken);\n\n      // These properties are all mutable, the destructure here is optional.\n      const { ongoingSplits, pageKeyToQuery, pageKeys } = paginatedQuery;\n\n      // Check for any completed splits\n      for (const [pageKey, [splitKey1, splitKey2]] of ongoingSplits) {\n        const bothNewPagesLoaded =\n          getResult(pageKeyToQuery.get(splitKey1)!.queryToken) !== undefined &&\n          getResult(pageKeyToQuery.get(splitKey2)!.queryToken) !== undefined;\n\n        if (bothNewPagesLoaded) {\n          this.completePaginatedQuerySplit(\n            paginatedQuery,\n            pageKey,\n            splitKey1,\n            splitKey2,\n          );\n        }\n      }\n\n      // Check each active page for splits needed\n      for (const pageKey of pageKeys) {\n        if (ongoingSplits.has(pageKey)) {\n          continue; // Already splitting\n        }\n\n        const pageToken = pageKeyToQuery.get(pageKey)!.queryToken;\n        const pageResult = getResult(pageToken);\n        if (!pageResult) {\n          continue;\n        }\n        const result = asPaginationResult(pageResult);\n\n        // Check if this page needs splitting\n        const shouldSplit =\n          result.splitCursor &&\n          (result.pageStatus === \"SplitRecommended\" ||\n            result.pageStatus === \"SplitRequired\" ||\n            // This client-driven page splitting condition will change in the future.\n            result.page.length > paginatedQuery.options.initialNumItems * 2);\n\n        if (shouldSplit) {\n          this.splitPaginatedQueryPage(\n            paginatedQuery,\n            pageKey,\n            result.splitCursor!, // we just checked\n            result.continueCursor,\n          );\n        }\n      }\n    }\n  }\n\n  private splitPaginatedQueryPage(\n    paginatedQuery: LocalPaginatedQuery,\n    pageKey: QueryPageKey,\n    splitCursor: string,\n    continueCursor: string | null,\n  ): void {\n    const splitKey1 = paginatedQuery.nextPageKey++;\n    const splitKey2 = paginatedQuery.nextPageKey++;\n\n    const paginationOpts: Value = {\n      cursor: continueCursor,\n      numItems: paginatedQuery.options.initialNumItems,\n      id: paginatedQuery.id,\n    };\n\n    // First split page: same cursor as original, but add endCursor at splitCursor\n    const firstSubscription = this.client.subscribe(\n      paginatedQuery.canonicalizedUdfPath,\n      {\n        ...paginatedQuery.args,\n        paginationOpts: {\n          ...paginationOpts,\n          cursor: null, // Start from beginning for first split\n          endCursor: splitCursor,\n        },\n      },\n    );\n    paginatedQuery.pageKeyToQuery.set(splitKey1, firstSubscription);\n\n    // Second split page: cursor starts at splitCursor, endCursor is the original continueCursor\n    const secondSubscription = this.client.subscribe(\n      paginatedQuery.canonicalizedUdfPath,\n      {\n        ...paginatedQuery.args,\n        paginationOpts: {\n          ...paginationOpts,\n          cursor: splitCursor,\n          endCursor: continueCursor,\n        },\n      },\n    );\n    paginatedQuery.pageKeyToQuery.set(splitKey2, secondSubscription);\n\n    paginatedQuery.ongoingSplits.set(pageKey, [splitKey1, splitKey2]);\n  }\n\n  /**\n   * @internal\n   */\n  private addPageToPaginatedQuery(\n    token: PaginatedQueryToken,\n    continueCursor: string | null,\n    numItems: number,\n  ): { queryToken: QueryToken; unsubscribe: () => void } {\n    const paginatedQuery = this.mustGetPaginatedQuery(token);\n    const pageKey = paginatedQuery.nextPageKey++;\n\n    const paginationOpts: Value = {\n      cursor: continueCursor,\n      numItems,\n      id: paginatedQuery.id,\n    };\n\n    const pageArgs = {\n      ...paginatedQuery.args,\n      paginationOpts,\n    };\n\n    const subscription = this.client.subscribe(\n      paginatedQuery.canonicalizedUdfPath,\n      pageArgs,\n    );\n\n    paginatedQuery.pageKeys.push(pageKey);\n    paginatedQuery.pageKeyToQuery.set(pageKey, subscription);\n    return subscription;\n  }\n\n  private removePaginatedQuerySubscriber(token: PaginatedQueryToken): void {\n    const paginatedQuery = this.paginatedQuerySet.get(token);\n    if (!paginatedQuery) {\n      return;\n    }\n\n    paginatedQuery.numSubscribers -= 1;\n    if (paginatedQuery.numSubscribers > 0) {\n      return;\n    }\n\n    // Remove all page subscriptions by calling their unsubscribe callbacks\n    for (const subscription of paginatedQuery.pageKeyToQuery.values()) {\n      subscription.unsubscribe();\n    }\n\n    this.paginatedQuerySet.delete(token);\n  }\n\n  private completePaginatedQuerySplit(\n    paginatedQuery: LocalPaginatedQuery,\n    pageKey: QueryPageKey,\n    splitKey1: QueryPageKey,\n    splitKey2: QueryPageKey,\n  ): void {\n    const originalQuery = paginatedQuery.pageKeyToQuery.get(pageKey)!;\n    paginatedQuery.pageKeyToQuery.delete(pageKey);\n    const pageIndex = paginatedQuery.pageKeys.indexOf(pageKey);\n    paginatedQuery.pageKeys.splice(pageIndex, 1, splitKey1, splitKey2);\n    paginatedQuery.ongoingSplits.delete(pageKey);\n    originalQuery.unsubscribe();\n  }\n\n  /** The query tokens for all active pages, in result order */\n  private activePageQueryTokens(\n    paginatedQuery: LocalPaginatedQuery,\n  ): QueryToken[] {\n    return paginatedQuery.pageKeys.map(\n      (pageKey) => paginatedQuery.pageKeyToQuery.get(pageKey)!.queryToken,\n    );\n  }\n\n  private allQueryTokens(paginatedQuery: LocalPaginatedQuery): QueryToken[] {\n    return Array.from(paginatedQuery.pageKeyToQuery.values()).map(\n      (sub) => sub.queryToken,\n    );\n  }\n\n  private queryTokenForLastPageOfPaginatedQuery(\n    token: PaginatedQueryToken,\n  ): QueryToken {\n    const paginatedQuery = this.mustGetPaginatedQuery(token);\n    const lastPageKey =\n      paginatedQuery.pageKeys[paginatedQuery.pageKeys.length - 1];\n    if (lastPageKey === undefined) {\n      throw new Error(`No pages for paginated query ${token}`);\n    }\n    return paginatedQuery.pageKeyToQuery.get(lastPageKey)!.queryToken;\n  }\n\n  private mustGetPaginatedQuery(\n    token: PaginatedQueryToken,\n  ): LocalPaginatedQuery {\n    const paginatedQuery = this.paginatedQuerySet.get(token);\n    if (!paginatedQuery) {\n      throw new Error(\"paginated query no longer exists for token \" + token);\n    }\n    return paginatedQuery;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
